#' Track constructor classes for MoveRakeR
#'
#' @description Functions to append object classes of \code{Track}, \code{TrackStack} and \code{TrackMultiStack},
#' obtained respectively using their respective namesake functions respectively; These
#' object classes are used in the \code{MoveRakeR} workflow, but are not essential for operation.
#'
#' @details  Three special object classes are returned from initial read in functions such as
#' \code{\link{read_track_MB}} and \code{\link{read_track_UvA}}. \code{Track} is typically representative
#' of an individual animal's time-series, but an 'rbinded' \code{Track}
#' object of several animals, i.e. multiple TagIDs, will also be accepted as a \code{Track}
#' object and processed for each individual, thus \code{Track} objects represent a single \code{data.frame} class; \code{TrackStack} and
#' \code{TrackMultiStack} objects are nested \code{list} formats, and (as currently implemented)
#' \emph{must be treated as one individual per data.frame}. These stacked listed methods
#' are intended for efficient application of routines for groups of animals. Objects can be coerced into
#' \code{Track}, \code{TrackStack} and \code{TrackMultiStack} classes but they require the following
#' minimum column names: \strong{TagID}, \strong{DateTime}, \strong{longitude} and \strong{latitude} -
#' see \code{\link{read_track_MB}} and \code{\link{read_track_UvA}}
#' for details of the full list of named variables contained from those extractions.
#' Further checking of whether objects belong to special classes are provided by: \code{link{is_Track}},
#' \code{link{is_TrackStack}} and \code{\link{is_TrackMultiStack}}, and coercing of two
#' \code{TrackStack} objects is provided by \code{\link{track_multi_stack}}.
#'
#' Further classes are specified for "trips" in the same stacked format as above
#' coercing to \code{Trip}, \code{TripStack} and \code{TripMultiStack} after
#' both \code{\link{define_trips}} and \code{\link{trip_stats}} functions have been run,
#' Trip classes eventually generated by the latter function.
#'
#' @seealso [MoveRakeR::Accn], [MoveRakeR::Pr], [MoveRakeR::track_multi_stack], [MoveRakeR::is_Track], [MoveRakeR::is_TrackStack], [MoveRakeR::is_TrackMultiStack], [MoveRakeR::is_Trip], [MoveRakeR::is_TripStack], [MoveRakeR::is_TripMultiStack]
#'
#' @param data An input base::data.frame for a tracking dataset that is to be
#' coerced to the designated class.
#' @return For tracking data, returns a \code{Track}, \code{TrackStack} or
#' \code{TrackMultiStack} class object and for Trip data, returns a
#' \code{Trip}, \code{TripStack} or \code{TripMultiStack} object.
#'
#' @export
Track <- function(data){
  if(is.null(data$TagID) | is.null(data$DateTime) | is.null(data$longitude)  | is.null(data$latitude) | ncol(data)<2)
    stop("Can't construct Track object: fields are missing or mispelled")

  if(!inherits(data$DateTime, "POSIXct")){
    stop("POSIXct format required for DateTime")
  }

  obj <- structure(.Data = data, class = c("Track","data.frame"))
  return(obj)
}
#' @rdname Track
#' @export
TrackStack <- function(data){
  if(!is.list(data)){
    stop("Can't construct TrackStack object: data are not a list")
  }
  if(is.null(data[[1]]$TagID) | is.null(data[[1]]$DateTime) | is.null(data[[1]]$longitude)  | is.null(data[[1]]$latitude)){
    stop("Can't construct TrackStack object: fields are missing or mispelled")
  }
  if(!inherits(data[[1]]$DateTime, "POSIXct")){
    stop("POSIXct format required for DateTime")
  }

  for(j in 1:length(data)){
    data[[j]] <- structure(.Data = data[[j]], class = c("Track","data.frame"))
  }
  obj <- structure(.Data = data, class = c("Track","TrackStack","list"))

  return(obj)
}

#' @rdname Track
#' @export
TrackMultiStack <- function(data){
  # expects lists in lists
  if(!is.list(data)[[1]]){
    stop("Can't construct TrackMultiStack object: data are not a list")}
  if(is.null(data[[1]][[1]]$TagID) | is.null(data[[1]][[1]]$DateTime) | is.null(data[[1]][[1]]$longitude)  | is.null(data[[1]][[1]]$latitude)){
    stop("Can't construct TrackMultiStack object: fields are missing or mispelled")
  }
  if(!inherits(data[[1]][[1]]$DateTime, "POSIXct")){
    stop("POSIXct format required for DateTime")
  }
  for(i in 1:length(data)){
    for(j in 1:length(data[[i]])){
      data[[i]][[j]] <- structure(.Data = data[[i]][[j]], class = c("Track","data.frame"))
    }
    data[[i]] <- structure(.Data = data[[i]], class = c("Track","TrackStack","list"))
  }
  obj <- structure(.Data = data, class = c("Track","TrackStack","TrackMultiStack","list"))
  return(obj)
}

#' @rdname Track
#' @export
Trip <- function(data){
  if(is.null(data$TagID) | is.null(data$DistMax) | is.null(data$TripDur) | ncol(data)<2)
    stop("Can't construct Trip object: fields are missing or mispelled")

  obj <- structure(.Data = data, class = c("Trip","data.frame"))

  return(obj)
}
#' @rdname Track
#' @export
Trip2 <- function(data){
  # n.b. this is a default class for data.frames to allow use of functions generically in base R
  if(is.null(data$TagID) | is.null(data$DistMax) | is.null(data$TripDur) | ncol(data)<2)
    stop("Can't construct Trip object: fields are missing or mispelled")

  obj <- structure(.Data = data, class = c("Trip2","data.frame"))
  return(obj)
}
#' @rdname Track
#' @export
TripStack <- function(data){
  if(!is.list(data))
    stop("Can't construct TripStack object: data are not a list")
  if(is.null(data[[1]]$TagID) | is.null(data[[1]]$DistMax) | is.null(data[[1]]$TripDur) | ncol(data[[1]])<2){
    stop("Can't construct TripStack object: fields are missing or mispelled")
  }

  for(j in 1:length(data)){
    data[[j]] <- structure(.Data = data[[j]], class = c("Trip","data.frame"))
  }
  obj <- structure(.Data = data, class = c("Trip","TripStack","list"))

  return(obj)
}

#' @rdname Track
#' @export
TripMultiStack <- function(data){
  # expects lists in lists
  if(!is.list(data)[[1]]){
    stop("Can't construct TripMultiStack object: data are not a list")}
  if(is.null(data[[1]][[1]]$TagID) | is.null(data[[1]][[1]]$DistMax) | is.null(data[[1]][[1]]$TripDur) | ncol(data[[1]][[1]])<2){
    stop("Can't construct TripMultiStack object: fields are missing or mispelled")
  }
  for(i in 1:length(data)){
    for(j in 1:length(data[[i]])){
      data[[i]][[j]] <- structure(.Data = data[[i]][[j]], class = c("Trip","data.frame"))
    }
    data[[i]] <- structure(.Data = data[[i]], class = c("Trip","TripStack","list"))
  }
  obj <- structure(.Data = data, class = c("Trip","TripStack","TripMultiStack","list"))
  return(obj)
}

#' is_Track
#'
#' Check that an object is of class \code{\link{Track}}, class \code{\link{TrackStack}} or class \code{\link{TrackMultiStack}}.
#'
#' @param x Object to be assesed.
#' @param strict For is_ functions, logical for should the class check search strictly for the
#' specific sub-class, e.g. TrackStack, or TrackMultiStack (default = TRUE), but if FALSE
#' then the function checks as a normal "is" or inherits for the super class, e.g. Track (even if object is a TS or TMS).
#' @return Logical \code{TRUE} if \code{x} belongs to class \code{\link{Track}}, \code{\link{TrackStack}} or \code{\link{TrackMultiStack}}, otherwise returns \code{FALSE}.
#' @export
is_Track <- function(x, strict = TRUE){
  if(strict == TRUE){
    inherits(x,"Track") & !inherits(x,"Track2") & !inherits(x,"TrackStack") & !inherits(x,"TrackMultiStack")
  } else{
    inherits(x,"Track")
  }
}
#' @rdname is_Track
#' @export
is_TrackStack <- function(x, strict = TRUE){
  if(strict == TRUE){
    inherits(x,"TrackStack") & !inherits(x,"TrackMultiStack")
  } else{
    inherits(x,"TrackStack")
  }
}
#' @rdname is_Track
#' @export
is_TrackMultiStack <- function(x, strict = TRUE){
  if(strict == TRUE){
    inherits(x,"TrackMultiStack")
  } else{
    inherits(x,"TrackMultiStack")
  }
}
#' @rdname is_Track
#' @export
is_Trip <- function(x, strict = TRUE){
  if(strict == TRUE){
    inherits(x,"Trip") & !inherits(x,"TripStack") & !inherits(x,"TripMultiStack")
  } else{
    inherits(x,"Trip")
  }
}
#' @rdname is_Track
#' @export
is_TripStack <- function(x, strict = TRUE){
  if(strict == TRUE){
    inherits(x,"TripStack") & !inherits(x,"TripMultiStack")
  } else{
    inherits(x,"TripStack")
  }
}
#' @rdname is_Track
#' @export
is_TripMultiStack <- function(x, strict = TRUE){
  if(strict == TRUE){
    inherits(x,"TripMultiStack")
  } else{
    inherits(x,"TripMultiStack")
  }
}

#' track_multi_stack
#'
#' Coerce \code{TrackStack} class objects into a \code{TrackMultiStack} class object.
#'
#' @param data Object to be assesed.
#'
#' @return Return new \code{data} coerced to a \code{\link{TrackMultiStack}} class.
#' @export
track_multi_stack <- function(data = NULL){
  if(!is_TrackStack(data[[1]])){stop("data should be a TrackStack class object")}
  data <- TrackMultiStack(data) # data should be a list(x,y)
  return(data)
}

#' @rdname track_multi_stack
#' @export
track_stack <- function(data = NULL){
  if(!is_Track(data[[1]])){stop("data should be a Track class object")}
  data <- TrackStack(data) # data should be a list(x,y)
  return(data)
}

#' @rdname track_multi_stack
#' @export
trip_multi_stack <- function(data = NULL){
  if(!is_TripStack(data[[1]])){stop("data should be a TripStack class object")}
  data <- TripMultiStack(data)
  return(data)
}

#' @noRd
is.Track <- is_Track
is.TrackStack <- is_TrackStack
is.TrackMultiStack <- is_TrackMultiStack
is.Trip <- is_Trip
is.TripStack <- is_TripStack
is.TripMultiStack <- is_TripMultiStack


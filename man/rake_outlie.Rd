% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rake_outlie.R
\name{rake_outlie}
\alias{rake_outlie}
\title{Simple outlier detection for covariates within telemetry data}
\usage{
rake_outlie(
  data,
  var = "dt",
  u_max = 300,
  q = c(0.01, 0.99),
  method = c("quantile", "boxplot", "Hampel"),
  plot = TRUE,
  annotate = TRUE,
  summary = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{data}{Input data object, with required columns: TagID, DateTime, longitude, latitude.}

\item{var}{The name of the variable to perform outlier assessment on, defaults to 'dt' (time steps).}

\item{u_max}{The upper maximum perceived limit to the variable, beyond which an estimation of outlying points is made,
defaults to 300 (s) matching the default 'dt' var. Note this is a separate process to 'method'.}

\item{q}{For quantile and Hampel methods, the lower and upper percentile values to be used (vector of length two), for which data
is considered outlying beyond these bounds; defaults to c(0.01,0.99).}

\item{method}{One of three methods "quantile", "boxplot" or "Hampel".}

\item{plot}{TRUE/FALSE (default FALSE) whether a ggplot plot is to be printed to the user on function completion,
showing the median, quartile bounds, and 'outlying' data points, with red point being outlying from the upper or lower bound
of the population, black points being within the animal's distribution.}

\item{annotate}{TRUE/FALSE (defaulting to FALSE) whether to provide a fully annotated dataset, with outliers flagged.}

\item{summary}{TRUE/FALSE (defaulting to TRUE) whether to provide a summary data.frame of the proportion of outliers per animal and in relatio to the population.}

\item{verbose}{TRUE (default) or FALSE whether to provide within-function messaging.}
}
\value{
This depends on the specification of the annotate and summary arguments; if summary = TRUE and annotate = FALSE,
then the function will return a data.frame for all animals, with outlier detection within the individual
for the variable chosen. The summary layout varies slightly depending on the method chosen. The format is as
follows (with brackets for columns specific to method):
\itemize{
\item TagID = animal identifier, with an 'all' row across animals;
\item n = the number of fixes for the animal;
\item min_val (quantile, Hampel) = the minimum value of the covariate;
\item lower_q (quantile) = the lower 25\% quartile from the boxplot function;
\item median (quantile, boxplot, Hampel) = the median value of the distribution;
\item upper_q (quantile) = the upper 75\% quartile from the boxplot function;
\item lower_ham (Hampel) = the lower bound of the Hampel interval (median - 3.MAD)
\item upper_ham (Hampel) = the upper bound of the Hampel interval (median + 3.MAD)
\item lower_whisker (Boxplot) = q0.25 - 1.5*IQR
\item lower_hinge (Boxplot) Tukey lower quartile
\item upper_hinge (Boxplot) Tukey upper quartile
\item upper_whisker (Boxplot) = = q0.75 + 1.5*IQR
}

Columns regardless of method used:
\itemize{
\item n_out = number of points beyond the lower and/or upper bounds per individual (or population for the 'all' data row).
The bounds taken are the lower_q:upper_q (quantile), the lower_whisker:upper_whisker (boxplot) or lower_ham:upper_ham (Hampel);
\item prop_out = proportion of individual animal data points outside the bounds of the individual animal's data range bound (as above per method);
\item n_out_ia = number of data point for the 'individual' that are outside the bods of the 'all' total population (i.e. 'ia');
\item prop_out_ia = proportion of individual animal data points outside the bounds of the population;
\item out_ratio = ration of n_out_ia/n_out, if this value is far above 1, then for that animal there are more fixes identified
outside the method-specific bounds than the bounds of the the all (population-level) data. Again, the function should be used
with caution as for so called 'good' data with no real outliers, the methods may differ in their summaries.
}

For annotated data, up to three additional columns are added, one for annotation if the method flagged data points outlying
the individual (column name format: 'outlier_i_VARNAME_METHOD\link{1}'), if points for the individual were outlying the population
distribution (column name format: 'outlier_ia_VARNAME_METHOD\link{1}'), and if the u_max argument is
not NULL, whether fixes were flagged as outlying the upper bound ('u_max' column). For boxplot the individual column name
outlier_i_VARNAME_METHOD\link{1} is flagged as "i" (either upper or lower outlier), and for Hampel and quantile methods,
further distinction is made for "i_u" and "i_l" for upper and lower. For the population-level 'outlier_ia_VARNAME_METHOD\link{1}',
all methods have upper ('ia_u') and lower ('ia_l') distinction, and in all cases zeros are those wors not flagged.
}
\description{
Assess the spread of data and existence of potential outliers for numeric/integer covariates alongside telemetry data
}
\details{
The \code{rake_outlie} function is a simple test for outliers within a chosen variable. This calculation is performed
for individual animals and then in relation to the total population. The resultant output therefore gives the user
an indication of outlier presence within individual in relation to the population.

Outlier detection is not always straightforward an there are many approaches available, and can depend on
the distribution of your data, e.g. statistical tests can requires assumptions of normality, such as z-scores. I would recommend this
interesting \href{https://statsandr.com/blog/outliers-detection-in-r/#fn4}{vignette} (Soetewey 2020) that describes many of the available
methods and other R packages available, such as \code{outliers} (Komsta 2022), \code{DMwR::lofactor} (Torgo 2010),
\code{mvoutlier} (Filzmoser & Gschwandtner 2021), \code{odetector} (Cebeci et al. 2022), \code{Rlof} (Hu et al. 2022)
and probably many more.

Outler detection is an important process within proposed workflows of
dealing with error in animal telemetry data (Fleming et al. 2020). Another R package that can help in this regard is
the \code{ctmm} package (Fleming & Calbrese 2020), specifically \code{ctmm:outlie} that specifically incorporates
GPS telemetry data error within its calculations.

The \code{rake_outlie} function is concerned with the overall distribution of covariate data, which
may include data such as speed derived from telemetry processes, or some other independent covariate that may require investigation.
Following the review by Soetewey (2020) above, the \code{rake_outlie} implements three simple approaches, "quantile", "boxplot", and "Hampel".
Of course the use of outlier tests will depend on your underlying data, as tests will
typically detect 'some' data points as being outlying even for 'good' data.

The 'quantile' approach used the quantile function using defined lower and upper percentiles of the distribution
that direct the function to label data points as outlying beyond each bound, e.g. lower 1\% or upper 99\%.
The 'boxplot' approach uses the boxplot function and the definitions of outliers that contains. The \code{rake_outlie}
function assumes outliers are those identified through the boxplot function, i.e. 1.5 x lower and upper quartiles.
The outliers for the Hampel filter are identified by the interval comprised of the median plus or minus three absolute
standard deviations and similarly to the other two methods, labelled as outlying beyond the Hampel range.

The \code{rake_outlie} function also allows the user to specify an upper perceived threshold more generically through
the \emph{u_max} argument that directs the function to look at the proportion of data beyond that bound.

A \emph{plot} argument can return the plot to the user, but this is accessible anyway after function run through the
attribute: \code{attr(, "plot_data")}. Here, the red dots are those data points above the \strong{population} upper bound
used (depending on the method specified), and any points above the individual animal upper bound are those assocaiated
with the individual animal's range.

This leads on to how \code{rake_outlie} summarises the outlying information within and between animals, and was the original
motivation for construction of the function. It is useful to know whether the distribution of the individual animal's covariate data is inherently more or less
outlying to that of the overall population across animals. This is provided as above visually, but is further detailed
in the returned data summary. This summary (see Value section below), contains a basic summary of the proportion of data
that was outlying for the individual animal distribution and further columns of proportion of outliers of the individual animal's data
was in relation to the population-level distribution. The function can then further annotate the original data supplied
by the outlier detection for specific variable tested. The data summary, however is a separate process that can
be called for with annotate as well, in that case being an attribute of the returned annotated dataset: \code{attr(attr(., "rake_outlie"), "summary")}.

Note at present only one variable can be supplied to the function at a time, and only one method per covariate can
be specified. We would stress again that care should be taken in the use of \code{rake_outlie} and that individual methods
ideally should be tested alongside others and full plotting and scrutiny of the data distibutions should be carried out.

The \code{ShinyRakeR} interactive Shiny app can be used to flag potential outlying data points, but at present does not
incorporate the processes here in \code{rake_outlie}, and thus before running the app, \code{rake_outlie} would need to be run first and
potential outlying variables translated to a 1,0 binary format (i.e. yes or no for an outlier), so that variables can be
visible to the app head of time.
}
\examples{
# assessing outlier potential in the 'traj.speed' (trajectory speed) variable of data

### returning the summary data with no annotation:

q <- rake_outlie(data = data, var = "traj.speed", u_max = NULL, q = c(0.01,0.99), method = "quantile",
                       plot = FALSE, annotate = FALSE, summary = TRUE, verbose = FALSE)

b <- rake_outlie(data = data, var = "traj.speed", u_max = NULL, q = c(0.01,0.99), method = c("boxplot"),
                       plot = FALSE, annotate = FALSE, summary = TRUE, verbose = FALSE)

h <- rake_outlie(data = data, var = "traj.speed", u_max = NULL, q = c(0.01,0.99), method = c("Hampel"),
                       plot = FALSE, annotate = FALSE, summary = TRUE, verbose = FALSE)

# plot data retained in the summary output as an attribute:
attr(q, "plot_data")

### annotated data (retaining summary)
q2 <- rake_outlie(data = data, var = "traj.speed", u_max = NULL, q = c(0.01,0.99), method = "boxplot",
                       plot = FALSE, annotate = TRUE, summary = TRUE, verbose = FALSE)

# accessing the summary data attribute
attr(attr(q2, "rake_outlie"), "summary") # equivalent to above with annotate = FALSE

# access the plot regardless of plot argument
attr(attr(q2, "rake_outlie"), "plot_data")

### check:
b2 <- rake_outlie(data = data, var = "traj.speed", u_max = NULL, q = c(0.01,0.99), method = c("boxplot"),
                       plot = FALSE, annotate = TRUE, summary = TRUE, verbose = FALSE)

# length of outlier column labelled here (e.g. for a column called 'traj.speed' boxplot method in this example:
nrow(b2[b2$outlier_i_traj.speed_b == "i",]) # <---
# nrow(q2[q2$outlier_i_traj.speed_q \%in\% c("i_u", "i_l"),]) # or this for quantile example

# should match sum here in summary excluding all population row:
a = attr(attr(b2,"rake_outlie"), "summary")
sum(a[a$TagID != "all",]$n_out) # <---

################# see also ###########
library(ctmm)
library(MoveRakeR)
data(buffalo)

# Outliers in Cilla
OUT <- outlie(buffalo[[1]])

# convert a Track object to move format for use in ctmm::outlie
data_2move <- MoveRakeR::Track2move(data)

test_ctmm <- ctmm::as.telemetry(data_2move)  # convert to ctmm from move
OUT <- ctmm::outlie(test_ctmm, plot = FALSE)

#####################
# another option is to use dbscan::lof() nearest neighbour clustering
#install.packages('dbscan')
library(dbscan)
install.packages("Rlof")
library(Rlof)

# Assuming data has latitude and longitude columns
dat1 <- data[!is.na(data$longitude) & !is.na(data$latitude),]

# LOF score: k = number of neighbors to consider
lof_scores <- lof(coords, minPts = 6)
lof_scores <- Rlof::lof(as.matrix(dat1[, c("longitude", "latitude")]), k = 5)
# Add LOF scores to your data
dat1$lof_score <- lof_scores
# Flag extreme outliers (say top 1\% of LOF)
threshold <- quantile(lof_scores, 0.99) # still using a quantile though here
dat1$lof_outlier <- lof_scores > threshold

#plot_leaflet(testdat[which(dat1$lof_outlier),])

##### speed up?
# Compute k nearest neighbors (say k = 5)
coords <- dat1[, c("longitude", "latitude")]
knn_res <- dbscan::kNN(coords, k = 5)

# Compute LOF using precomputed kNN
lof_scores <- lof(coords, minPts = 6, search = knn_res)

# Attach scores to data
dat1$lof_score <- lof_scores

}
\references{
Cebeci, Z., Cebeci, C., Tahtali, Y. and Bayyurt, L. 2022. Two novel outlier detection
approaches based on unsupervised possibilistic and fuzzy clustering. PeerJ Computer Science 8:e1060.
\url{https://doi.org/10.7717/peerj-cs.1060}.

Filzmoser P, Gschwandtner M (2021). mvoutlier: Multivariate Outlier Detection Based on Robust Methods.
R package version 2.1.1, \url{https://CRAN.R-project.org/package=mvoutlier}.

Fleming, C.H., Drescher-Lehman, J.. Noonan, M.J., Akre, T.S.B., Brown, D.J., Cochrane, M.M., Dejid, N., DeNicola, V.,
DePerno, C.S., Dunlop, J.N., Gould, N.P., Harrison, A.-L., Hollins, J., Ishii, H., Kaneko, Y., Kays, R., Killen, S.S.,
Koeck, B., Lambertucci, S.A., LaPoint, S.D., Medici, E.P., Meyburg, B.-U., Miller, T.A., Moen, R.A., Mueller, T.,
Pfeiffer, T., Pike, K.N., Roulin, A., Safi, K., SÃ©chaud, R., Scharf, A.K., Shephard, J.M., Stabach, J.A., Stein, K.,
Tonra, C.M., Yamazaki, K., Fagan, W.F. & Calabrese, J.M. (2020) A comprehensive framework for handling location error
in animal tracking data. bioRxiv 2020.06.12.130195; doi: \url{https://doi.org/10.1101/2020.06.12.130195}.

Fleming C.H. & Calabrese J.M. (2025) ctmm: Continuous-Time Movement Modeling.
R package version 1.3.0. \url{https://CRAN.R-project.org/package=ctmm}.

Hu Y, Murray W, Shan Y, Australia. (2022). Rlof: R Parallel Implementation of Local Outlier Factor(LOF).
R package version 1.1.3. \url{https://CRAN.R-project.org/package=Rlof}.

Komsta L (2022). outliers: Tests for Outliers. R package version 0.15. \url{https://CRAN.R-project.org/package=outliers}.

Soetewey, A. (2020) Outliers detection in R, Stats and R. \url{https://statsandr.com/blog/outliers-detection-in-r/#fn4}.

Torgo, L. (2010). Data Mining with R, learning with case studies Chapman and Hall/CRC. \url{http://www.dcc.fc.up.pt/~ltorgo/DataMiningWithR}.
}
\seealso{
\link{rake}, \link{ShinyRakeR}
}

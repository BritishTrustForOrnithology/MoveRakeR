% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_Track_arrows.R
\name{plot_track_arrows}
\alias{plot_track_arrows}
\alias{plot_track_arrows.Track}
\alias{get_angle_coords}
\alias{arrow_plot_prep}
\alias{arrow_transform}
\title{Ploting arrows along a Track}
\usage{
plot_track_arrows(data, ...)

\method{plot_track_arrows}{Track}(
  data,
  tol = 0.5,
  u = 100,
  nnew = 500,
  r = NULL,
  N_keep = NULL,
  col = "black",
  corr_no_arr = 0.005,
  corr_size_arr = 0.35,
  geo_transform = TRUE,
  verbose = TRUE,
  p4s = 32631,
  ...
)

get_angle_coords(angle, tol = 0.3, r = 500)

arrow_plot_prep(x, tol = 0.5, r = 500)

arrow_transform(x, p4s = 32631)
}
\arguments{
\item{data}{A \code{Track} family object.}

\item{...}{further arguments passed to or from other methods.}

\item{tol}{'Tolerance' value in radians for the mount of angle to add and subtract from the
direction of movement to form the arrow head; defaults to 0.5.}

\item{u}{The \emph{u} argument in function \code{adehabitatLT::redisltraj}, here set to
100 m (default) for constant spatial interpolation at fine scales, but may not
be fine enough for some very detailed data sections.}

\item{nnew}{The \emph{nnew} argument in function \code{adehabitatLT::redisltraj},
here set to 500 by default.}

\item{r}{Direct size value of the length of arrows to plot;
defaults to 500 metres (assuming UTM projection) in the sub-functions of \code{get_angle_coords} and
\code{arrow_plot_prep} but is calculated dynamically in the
\code{plot_track_arrows} function so does not need to be edited directly, instead controlled
by the \emph{corr_size_arr} argument. However, an \emph{r} value can be supplied directly
to the \code{arrow_plot_prep} if need be. This value will therefore take on a different
meaning - see below. A further complexity is that for groups
of animals, the same size arrows are needed across all, hence a common
extent is needed. Thus, in the \code{arrow_plot_prep} function, if a \code{TrackStack}
or \code{TrackMultiStack} is detected, the mn_extent / mn_extent^corr_size_arr
formula will be taken for the across animal extent automatically, using the \emph{corr_size_arr}.
But if only a \code{TracK} is supplied and if \emph{r} is not NULL, then the
\emph{r} will need to be the mn_extent / mn_extent^corr_size_arr resultant value supplied
directly, hence e.g. could be if you want to manually use a wider custom extent for the arrow size.
This latter option is most handy for automatic use in the \code{plot.Track} function
that works on a bird-by-bird basis so needed direct use of \emph{r} in that instance.}

\item{N_keep}{A direct supplied value for number of arrows to plot (or rather
number of rows in interpolated data to keep for plotting), defaults to NULL for automatical calculation
based on the \emph{corr_no_arr} argument.}

\item{col}{Colour of the arrow to be plotted, defaults to "black".}

\item{corr_no_arr}{Value to control the number of arrows to plot
along the trajectory. The number of rows of the interpolated dataset
via \code{adehabitatLT} calculation, is first adjusted by proportion thus
\emph{N_keep = nrows*corr_no_arr}, with \emph{corr_no_arr} defaulting to a value of 0.005
retaining one fix in every 200 interpolated;
this is used further to give row number identifiers for fixes along the route to retain,
is used in the equation: \emph{row_keep = seq(2, nrows, (nrows/N_keep))}, and therefore acts as a means of retaining the number of rows of
the interpolated fixes to retain for plotting. Note, \emph{N_keep} can
also be supplied directly, in which case a direct value is fed in for the
number of rows to keep, otherwise, if NULL, will be calculated automatically as above.}

\item{corr_size_arr}{Value to control the size of arrows along the
trajectory, defaults to 0.35; this is used as an exponent
in relation the mean extent (m) of the animal: r = m / m^corr_size_arr,
used further to dynamically plot the size of the arrow over changing spatial
extents - thus fed into worker functions \code{arrow_plot_prep} and \code{plot_track_arrows}
to adjust the \emph{r} parameter.}

\item{geo_transform}{Logical (defaults to TRUE) to transform the coordinates of the arrow lines to WGS84 geographic cartesian.}

\item{verbose}{Logical defaulting to TRUE for detailed messaging.}

\item{p4s}{A numeric or \code{sf} \code{CRS} argument, here defaulting to the UTM 31N (32631).}

\item{angle}{Turning angle to be assessed for adding and subtracting bearing
from to form the arrow in the plots; used only in function \code{get_angle_coords}; user
should not have to worry about this.}

\item{x}{Input data into sub-functions \code{arrow_plot_prep} and \code{arrow_transform};
user need not use this, as called in function stack.}
}
\description{
Plotting directional movement arrows along the route of an animal.
}
\details{
The function \code{plot_track_arrows} plots arrows along a
route of an animal indicating direction of movement. This function works by using basic
trigonometry to plot Cartesian coordinates for interpolated
re-locations along an animal's trajectory. The number of arrows
can be adjusted along the route by altering the \emph{corr_no_arr}
argument and the size length of the arrows either side of the line can be
altered with the \emph{corr_size_arr} argument. Further, the user can specify
the angle of the arrow by adjusting the \code{tol} argument. The latter
specifies a certain amount of tolerance around the direction of the animal
that is added and subtracted from the turning angle of movement between fixes, i.e.
increasing 'tol' widens the angle of the arrow. The function operates
by first interpolateing the track in space using \code{adehabitatLT},
i.e. so that arrows can be drawn along any route of the animal between
observed fixes.

The function calls three other functions the user need not worry about,
but just for information: \code{get_angle_coords} to do the mathematics
of the arrow calculations, \code{arrow_plot_prep},
which calls \code{get_angle_coords} for each interpolated fix,
and \code{arrow_transform} which converts the coordinates to the chosen
projection system.

The main \code{plot_track_arrows} function therefore does the
spatial interpolation, calling the function stack, and
also makes use of other \code{MoveRakeR}
functions \code{project_points} and \code{get_bounds}. Arrows are
plotted using base graphics using the \code{segments} function. The \code{plot_track_arrows} function also needs the function \emph{gap_section}, or
equivalent naming of gapsections from other functions or user-manual identification,
to provide as 'bursts' to the \code{adehabitatLT} functions for interpolation. This is
to make sure no interpolation is done over excessive gaps in the dataset.

The \code{plot_track_arrows} function is also now
used directly in the \code{plot.Track} function specifying arrows directly
in the main plotter at a higher level, with a call to \code{plot_track_arrows}. See examples.
}
\examples{
indata <- yourdata # data.frame with a minimum of columns named TagID, DateTime, longitude, latitude
data <- Track(indata) # optional to convert to in-house class (most functions will still run on non track data but generic S3 methods will not be available for plot and summary)
p4 <- 4326

### European shape as an example
# R packages not bundled with MoveRakeR
#remotes::install_github("ropensci/rnaturalearthhires")
#install.packages('rnaturalearth')
library(rnaturalearthhires)
library(rnaturalearth)

spdf_world <- ne_download(scale = 10, type = "countries")
Europe <- spdf_world[spdf_world$SUBREGION \%in\% c("Western Europe","Eastern Europe","Northern Europe","Southern Europe"),]
Europe_sf = st_crop(Europe, xmin = -25, ymin=32, xmax=35, ymax=70)
Europe_sf <- sf::st_transform(Europe_sf, p4)
plot(Europe_sf$geometry)

# resample to get as 5 min trajectory for simplicity
data = sub_samp(data, 300, tol = 0.4, drop = FALSE)

# projection
p4s = 32631

opar = par()
par(mar = c(0,0,0,0))
par(oma = c(0,0,0,0))

# plot using the plot method for 'Track' objects
plot(Europe_sf$geometry, border = "black", col = "wheat", xlim = c(-4,-2.6), ylim = c(53.8,54.4))
plot(data, ADD=TRUE)
plot(Europe_sf$geometry, border = "black", add=TRUE)

# test adding arrows
plot_track_arrows(data, col = "red")
plot_track_arrows(data, col = "grey")

plot_track_arrows(data, col = "black", corr_size_arr = 0.45) # smaller
plot_track_arrows(data, col = "black", corr_size_arr = 0.45, corr_no_arr = 0.010) # smaller and more numerous
plot_track_arrows(data, col = "black", corr_size_arr = 0.45, corr_no_arr = 0.050) # smaller and even more numerous

# which can look a bit ugly for lots of lines!

# --------------------------- #
# The plot_track_arrows function is also implemented in the main
# plot function for Track objects (S3 method)

plot(Europe_sf$geometry, border = "black", col = "wheat", xlim = c(-4,-2.6), ylim = c(53.8,54.4))
plot(data, ADD=TRUE, anims = "uniq", arrows = TRUE, Points = TRUE, corr_size_arr = 0.38)

# Use in the plot function takes the colours of the Tracks per animal
# or per Stack (for TMS objects)
# See the ?plot.Track help for more details

############################## END ###########################

}

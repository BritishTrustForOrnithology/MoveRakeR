% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_cag_trips.R
\name{add_cag_trips}
\alias{add_cag_trips}
\alias{get_cag_trips}
\alias{reset_cag_trips}
\title{Dealing with 'come-and-go' trips directly in Track data}
\usage{
add_cag_trips(data)

get_cag_trips(data, log = FALSE)

reset_cag_trips(data)
}
\arguments{
\item{data}{The Track data object that should contain an attribute \code{attr(attr(data, 'define_trips'), 'extra_rows')}}

\item{log}{A boolean defaulting to FALSE for use in \code{get_cag_trips} to return (if TRUE) a logical TRUE if extra_rows
were found in the data attributes, otherwise, FALSE is returned. If log is FALSE then the actual duplicate data are returned if found.}
}
\description{
Functions to extract, add and remove extra information for come-and-go trips after the \code{define_trips}
function and prior to use of \code{trips_stats}.
}
\details{
An issue with assigning trips to data is that issues can arise where the GPS sampling interval is not of
sufficient temporal resolution to register a unique start and end point for each trip. By default the \code{define_trips}
function assesses such conditions of trips, here defined as trips of an animal that appear 'come-and-go' (i.e. arrive and then depart again)
from a central place. Such trips will share a start or end with a neighbouring trip.
For the subsequent processing of trips in function \code{trip_stats} require each trip to have a unique
start and end DateTime. The way this is handled in \code{MoveRakeR} is to include duplicate data to correctly assess trip metrics.
These extra rows are by default not included directly in the return \code{Track} data output to avoid potential issues
in further downstream analyses, but instead are stored in an attribute of the data:
\code{attr(attr(data, 'define_trips'), 'extra_rows')}.

Should you proceed directly from \code{define_trips} to
\code{trip_stats} there should be no issue, and such come-and-go conditions will be deal with automatically. However, if you
want to subset your data, or convert the data to and from other data object classes, then this can
result in either incorrect storage of such duplicate data or even lose the attribute for duplicates all together,
particularly using base R operation such as \code{data.frame()}, \code{cbind()} and so forth, meaning
you may see an error in \code{trip_stats} where extra_rows were not found. To get around this issue, some additional functions
are available to help.

Should you be converting between data classes or sub-setting your data between the running of
\code{define_trips} and \code{trip_stats}, it is safer to add the (potential) extra_rows for come-and-go trips
that you may have back into the Track object directly, then do your subset operations, and then run \code{trip_stats}.

The function \code{add_cag_trips} looks for the presence of extra duplicate data rows in the Track object attribute,
and adds them directly to the Track object, in turn removing them as an attribute from the Track object. The reverse
operation is performed by \code{reset_cag_trips} that looks for the presence of an 'extra_rows' column directly in the data
with a 1 for duplicate data rows and 0 for not, and adds the duplicates back as the data attribute, and removing the
duplicates from the main Track object. The final function \code{get_cag_trips} simply looks for such added rows
in the Track data attribute if available, and returns them as a direct object, or if log = TRUE, returns a logical
detecting the presence or absence of such duplicate data.

Apologies if this is inconvenient; other options such as R6 classes may be better suited to this task and may be updated in the future.
}
\examples{

indata <- data_in \%>\% clean_GPS(speed_filt = TRUE, drop = FALSE) \%>\%
 define_trips(method="rect", lls = c(-3.2, 54.0553,-3.1689, 54.0437))

# additional data may have been added to the Track object
indata$test1 <- 1
indata$test2 <- 2

# this base R subset preserves the Track data attribute for 'extra_rows'
data1 = subset(indata, select = c(TagID, longitude,latitude, test1, DateTime, speed_3d, altitude, test2))

# but you may also have inadvertently names another column the same called extra_row, that here is
# expected to be used to indicate 1 = duplicate and 0 = non duplicate rows
data1$extra_row <- 1:nrow(data1)

## 1. You can add the extra_rows back in the Track data by:
data_ <- add_cag_trips(data1)

# A message will indicate extra_rows are detected, however warnings will be given in this example
# where non-zero extra_row information was present in the extra_row column in the Track data
# your existing column extra_rows would be preserved as '__extra_rows__' but then removed using reset_cag_trips()

# the attributes from te Track object will have been NULLed out as the duplicate data are now in
# your Track data. This makes it safe to do further sub-setting and then run trip_stats()
attr(attr(data_, "define_trips"), "extra_rows") # NULL

nrow(data_) # should be larger than as nrow(indata)

## 2. You can if you like though, go back to the original (preferred) layout of
## having duplicate row data stored in the attribute not in the data:

data_2 <- reset_cag_trips(data_)
attr(attr(data_2, "define_trips"), "extra_rows") # extra rows now present again

nrow(data_2) # should be the same as nrow(indata)

## 3. Test for presence of or return (default) the duplicate row_data after define_trips() run:

get_cag_trips(indata, log = FALSE)
get_cag_trips(indata, log = TRUE) # returns TRUE

# or for above example after insertion of duplicate rows back in the Track data
get_cag_trips(data_2, log = FALSE)
get_cag_trips(data_2, log = TRUE)

# Also note that duplicate rows ONLY relevant information for DateTime, longitude, latitude and TagID;
# all other variables from duplicate fixes are NA for duplicate rows.

}
\seealso{
\link{define_trips}, \link{trip_stats}
}
